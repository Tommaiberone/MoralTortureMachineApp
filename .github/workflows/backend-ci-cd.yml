name: Backend CI/CD

on:
  push:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/backend-ci-cd.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'backend/**'
      - '.github/workflows/backend-ci-cd.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      populate_dynamodb:
        description: 'Populate DynamoDB with fresh data'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: eu-west-1
  TERRAFORM_VERSION: 1.9.0
  PYTHON_VERSION: '3.11'
  DYNAMODB_TABLE_NAME: moral-torture-machine-dilemmas

jobs:
  # Job 1: Lint e Test del codice
  lint-and-test:
    name: Lint & Test
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
          enable-cache: false

      - name: Cache uv dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/uv
          key: ${{ runner.os }}-uv-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-uv-

      - name: Install dependencies with uv
        run: |
          uv pip install --system -r requirements.txt

      - name: Lint with ruff (if configured)
        continue-on-error: true
        run: |
          uv pip install --system ruff
          ruff check backend_fastapi.py populate_dynamodb.py populate_dynamodb_multilang.py || true

      - name: Check Python syntax
        run: |
          python -m py_compile backend_fastapi.py
          python -m py_compile populate_dynamodb.py
          if [ -f populate_dynamodb_multilang.py ]; then
            python -m py_compile populate_dynamodb_multilang.py
          fi

  # Job 2: Terraform Plan (solo per PR)
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: lint-and-test
    if: github.event_name == 'pull_request'
    defaults:
      run:
        working-directory: ./backend/terraform

    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init
        run: terraform init

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -no-color -var="groq_api_key=${{ secrets.GROQ_API_KEY }}" -out=tfplan
          terraform show -no-color tfplan > plan.txt
        continue-on-error: true

      - name: Comment PR with Plan
        uses: actions/github-script@v7
        if: github.event_name == 'pull_request'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('backend/terraform/plan.txt', 'utf8');
            const output = `#### Terraform Backend Plan

            <details><summary>Show Plan</summary>

            \`\`\`terraform
            ${plan.substring(0, 65000)}
            \`\`\`

            </details>

            *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  # Job 3: Deploy Backend (Lambda + Terraform)
  deploy:
    name: Deploy Backend to AWS
    runs-on: ubuntu-latest
    needs: lint-and-test
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    defaults:
      run:
        working-directory: ./backend

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
          enable-cache: false

      - name: Cache uv dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/uv
          key: ${{ runner.os }}-uv-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-uv-

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Build Lambda deployment package with pip
        run: |
          rm -rf lambda_deployment lambda_function.zip
          mkdir -p lambda_deployment
          cp backend_fastapi.py lambda_deployment/

          # Install dependencies using pip with Lambda-compatible platform targeting
          cd lambda_deployment
          pip install \
            --target . \
            --platform manylinux2014_x86_64 \
            --implementation cp \
            --python-version ${{ env.PYTHON_VERSION }} \
            --only-binary=:all: \
            -r ../requirements.txt

          # Create zip file
          zip -q -r ../lambda_function.zip .
          cd ..

          echo "Lambda package size:"
          du -h lambda_function.zip

      - name: Terraform Init
        working-directory: ./backend/terraform
        run: terraform init

      - name: Terraform Apply
        working-directory: ./backend/terraform
        run: |
          terraform apply -auto-approve \
            -var="groq_api_key=${{ secrets.GROQ_API_KEY }}" \
            -var="force_rebuild=false"

      - name: Get API Endpoint
        id: api-endpoint
        working-directory: ./backend/terraform
        run: |
          API_URL=$(terraform output -raw api_endpoint)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "API Endpoint: $API_URL"

      - name: Test API Health
        run: |
          API_URL="${{ steps.api-endpoint.outputs.api_url }}"
          echo "Testing API at: $API_URL"

          # Health check
          curl -f "$API_URL/" || exit 1

          # Test get-dilemma endpoint
          curl -f "$API_URL/get-dilemma" || exit 1

          echo "‚úÖ API health check passed!"

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ‚úÖ Backend Deployment Successful

          **Environment:** ${ENVIRONMENT:-production}
          **API Endpoint:** ${{ steps.api-endpoint.outputs.api_url }}
          **Region:** ${{ env.AWS_REGION }}
          **Commit:** ${{ github.sha }}

          ### Test the API
          \`\`\`bash
          # Health check
          curl ${{ steps.api-endpoint.outputs.api_url }}/

          # Get a dilemma (English)
          curl ${{ steps.api-endpoint.outputs.api_url }}/get-dilemma?language=en

          # Get a dilemma (Italian)
          curl ${{ steps.api-endpoint.outputs.api_url }}/get-dilemma?language=it

          # View API docs
          open ${{ steps.api-endpoint.outputs.api_url }}/docs
          \`\`\`
          EOF

  # Job 4: Populate DynamoDB (opzionale)
  populate-dynamodb:
    name: Populate DynamoDB
    runs-on: ubuntu-latest
    needs: deploy
    if: |
      github.ref == 'refs/heads/main' &&
      (github.event.inputs.populate_dynamodb == 'true' || contains(github.event.head_commit.message, '[populate-db]'))

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install boto3
        run: pip install boto3

      - name: Check dilemma files
        working-directory: backend
        run: |
          echo "üìã Checking dilemma files..."

          if [ -f "dilemmas_it.json" ] && [ -f "dilemmas.json" ]; then
            echo "Found multilingual dilemma files"
            echo "MULTILANG=true" >> $GITHUB_ENV

            en_count=$(jq '. | length' dilemmas.json)
            it_count=$(jq '. | length' dilemmas_it.json)

            echo "‚úÖ Found $en_count English dilemmas"
            echo "‚úÖ Found $it_count Italian dilemmas"
          elif [ -f "dilemmas.json" ]; then
            echo "Found single language dilemma file"
            echo "MULTILANG=false" >> $GITHUB_ENV

            count=$(jq '. | length' dilemmas.json)
            echo "‚úÖ Found $count dilemmas"
          else
            echo "‚ùå Error: No dilemma files found!"
            exit 1
          fi

      - name: Backup current DynamoDB data
        run: |
          echo "üíæ Creating backup of current DynamoDB data..."
          timestamp=$(date +%Y%m%d-%H%M%S)
          backup_name="backup-$timestamp"

          aws dynamodb create-backup \
            --table-name ${{ env.DYNAMODB_TABLE_NAME }} \
            --backup-name "$backup_name" \
            --region ${{ env.AWS_REGION }}

          echo "‚úÖ Backup created: $backup_name"

      - name: Populate DynamoDB
        working-directory: backend
        run: |
          echo "üìä Populating DynamoDB table: ${{ env.DYNAMODB_TABLE_NAME }}"

          if [ "$MULTILANG" = "true" ]; then
            echo "Using multilingual populate script"
            python3 -u populate_dynamodb_multilang.py ${{ env.DYNAMODB_TABLE_NAME }} <<EOF
          yes
          EOF
          else
            echo "Using single language populate script"
            python3 populate_dynamodb.py \
              ${{ env.DYNAMODB_TABLE_NAME }} \
              dilemmas.json
          fi

          echo "‚úÖ DynamoDB populated successfully!"

      - name: Verify population
        run: |
          echo "üîç Verifying DynamoDB content..."

          # Get total count
          total_count=$(aws dynamodb describe-table \
            --table-name ${{ env.DYNAMODB_TABLE_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Table.ItemCount' \
            --output text)

          echo "üìä Total items in table: $total_count"

          if [ "$total_count" -eq 0 ]; then
            echo "‚ùå Error: No items in DynamoDB table!"
            exit 1
          fi

          echo "‚úÖ DynamoDB verification passed!"

      - name: Test API with populated data
        needs: deploy
        run: |
          echo "üß™ Testing API with new data..."

          # Get API URL from previous job
          API_URL="${{ needs.deploy.outputs.api_url }}"

          if [ -z "$API_URL" ]; then
            # Fallback to hardcoded URL if needed
            API_URL="https://wxe53u88o8.execute-api.eu-west-1.amazonaws.com"
          fi

          echo "Testing at: $API_URL"

          echo "Testing English endpoint..."
          response=$(curl -s "$API_URL/get-dilemma?language=en")
          if echo "$response" | jq -e '._id' > /dev/null; then
            echo "‚úÖ English dilemmas working"
          else
            echo "‚ùå English dilemmas not working"
            exit 1
          fi

          echo "Testing Italian endpoint..."
          response=$(curl -s "$API_URL/get-dilemma?language=it")
          if echo "$response" | jq -e '._id' > /dev/null; then
            echo "‚úÖ Italian dilemmas working"
          else
            echo "‚ö†Ô∏è Italian dilemmas not available (might be single language setup)"
          fi

          echo "‚úÖ API tests completed!"

      - name: DynamoDB Summary
        run: |
          echo "### ‚úÖ DynamoDB Populated Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Table:** ${{ env.DYNAMODB_TABLE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Region:** ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY

  # Job 5: Notifiche in caso di fallimento
  notify:
    name: Notify on Failure
    runs-on: ubuntu-latest
    needs: [lint-and-test, deploy]
    if: failure() && github.ref == 'refs/heads/main'

    steps:
      - name: Create failure summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ‚ùå Backend Deployment Failed

          **Branch:** ${{ github.ref_name }}
          **Commit:** ${{ github.sha }}
          **Author:** ${{ github.actor }}

          Please check the workflow logs for details.
          EOF
