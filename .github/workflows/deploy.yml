# Deploy backend and frontend to dev or prod environment based on branch
name: Deploy Full Stack

# Trigger: Deploy to dev on develop branch, prod on main branch
on:
  push:
    branches:
      - main      # Production
      - develop   # Development
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      populate_dynamodb:
        description: 'Populate DynamoDB with fresh data'
        required: false
        default: false
        type: boolean
      invalidate_cache:
        description: 'Invalidate CloudFront cache'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: eu-west-1
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'
  TERRAFORM_VERSION: 1.9.0
  TF_VERSION_FRONTEND: '1.9.5'

jobs:
  # Job 0: Determine environment based on branch or input
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      dynamodb_table: ${{ steps.set-env.outputs.dynamodb_table }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="prod"
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            ENV="dev"
          else
            ENV="dev"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Deploying to: $ENV"

  # Job 1: Lint e Test Backend
  backend-lint-test:
    name: Backend Lint & Test
    runs-on: ubuntu-latest
    needs: setup
    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
          enable-cache: false # Disabilitato cache perchÃ© non esiste uv.lock

      - name: Install dependencies
        run: uv pip install --system -r requirements.txt

      - name: Lint with ruff
        continue-on-error: true
        run: |
          uv pip install --system ruff
          ruff check . || true

      - name: Check Python syntax
        run: |
          python -m py_compile backend_fastapi.py
          python -m py_compile populate_dynamodb_multilang.py
          python -m py_compile populate_story_flows.py

  # Job 2: Deploy Backend
  backend-deploy:
    name: Deploy Backend (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, backend-lint-test]
    defaults:
      run:
        working-directory: ./backend

    permissions:
      contents: read
      id-token: write

    outputs:
      api_url: ${{ steps.api-endpoint.outputs.api_url }}

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Build Lambda package
        run: |
          rm -rf lambda_deployment lambda_function.zip
          mkdir -p lambda_deployment
          cp backend_fastapi.py lambda_deployment/

          cd lambda_deployment
          pip install \
            --target . \
            --platform manylinux2014_x86_64 \
            --implementation cp \
            --python-version ${{ env.PYTHON_VERSION }} \
            --only-binary=:all: \
            -r ../requirements.txt

          zip -q -r ../lambda_function.zip .
          cd ..

          echo "ðŸ“¦ Lambda package size: $(du -h lambda_function.zip)"

      - name: Create/Update Secrets Manager Secret
        run: |
          SECRET_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-groq-api-key"

          # Check if secret exists
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Secret exists, updating..."
            aws secretsmanager put-secret-value \
              --secret-id "$SECRET_NAME" \
              --secret-string "${{ secrets.GROQ_API_KEY }}" \
              --region ${{ env.AWS_REGION }}
          else
            echo "Secret does not exist, will be created by Terraform"
          fi

      - name: Terraform Init & Apply
        working-directory: ./backend/terraform
        env:
          TF_VAR_groq_api_key: ${{ secrets.GROQ_API_KEY }}
          TF_VAR_environment: ${{ needs.setup.outputs.environment }}
          TF_VAR_stack_name: moral-torture-machine
        run: |
          terraform init

          # Select or create workspace
          terraform workspace select ${{ needs.setup.outputs.environment }} || terraform workspace new ${{ needs.setup.outputs.environment }}

          # Apply with environment variables
          terraform apply -auto-approve

      - name: Get API Endpoint
        id: api-endpoint
        working-directory: ./backend/terraform
        run: |
          API_URL=$(terraform output -raw api_endpoint)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "âœ… API Endpoint: $API_URL"

      - name: Test API Health
        run: |
          API_URL="${{ steps.api-endpoint.outputs.api_url }}"
          echo "ðŸ§ª Testing API at: $API_URL"
          sleep 10 # Aggiunto un breve delay per dare tempo all'API Gateway di propagarsi

          # Test root endpoint
          echo "Testing root endpoint..."
          curl -f -s --retry 3 --retry-delay 5 "$API_URL/" || exit 1

          # Test get-dilemma endpoint (may fail if DB is empty, but API should still return 500)
          echo "Testing get-dilemma endpoint..."
          RESPONSE=$(curl -s --retry 3 --retry-delay 5 "$API_URL/get-dilemma" -w "%{http_code}" -o /tmp/response.txt)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)

          # Accept 200 (success), 404 (no dilemmas), or 500 (empty DB) as valid responses
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "404" ] && [ "$HTTP_CODE" != "500" ]; then
            echo "âŒ Unexpected HTTP code: $HTTP_CODE"
            cat /tmp/response.txt
            exit 1
          fi

          echo "âœ… API health check passed! HTTP Code: $HTTP_CODE"

      - name: Cleanup Lambda package
        run: |
          rm -rf lambda_function.zip lambda_deployment
          echo "ðŸ§¹ Cleaned up temporary Lambda files"

  # Job 3: Deploy Frontend Infrastructure
  frontend-infrastructure:
    name: Frontend Infrastructure (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: setup
    defaults:
      run:
        working-directory: frontend/terraform

    permissions:
      contents: read
      id-token: write

    outputs:
      bucket_name: ${{ steps.outputs.outputs.bucket_name }}
      distribution_id: ${{ steps.outputs.outputs.distribution_id }}
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION_FRONTEND }}

      - name: Terraform Init & Apply
        env:
          TF_VAR_environment: ${{ needs.setup.outputs.environment }}
          TF_VAR_stack_name: moral-torture-machine
          TF_VAR_domain_name: ${{ needs.setup.outputs.environment == 'prod' && 'moraltorturemachine.com' || '' }}
          TF_VAR_use_custom_domain: ${{ needs.setup.outputs.environment == 'prod' && 'true' || 'false' }}
        run: |
          terraform init

          # Select or create workspace
          terraform workspace select ${{ needs.setup.outputs.environment }} || terraform workspace new ${{ needs.setup.outputs.environment }}

          # Apply with environment variables
          terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: outputs
        run: |
          echo "bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
          echo "distribution_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "frontend_url=$(terraform output -raw frontend_url)" >> $GITHUB_OUTPUT

  # Job 4: Build e Deploy Frontend
  frontend-deploy:
    name: Build & Deploy Frontend (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, frontend-infrastructure]
    defaults:
      run:
        working-directory: frontend

    permissions:
      contents: read
      id-token: write

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          cache-dependency-path: frontend/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Build frontend
        run: pnpm build --mode ${{ needs.setup.outputs.environment }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        run: |
          aws s3 sync dist/ s3://${{ needs.frontend-infrastructure.outputs.bucket_name }}/ --delete

      - name: Invalidate CloudFront cache
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.invalidate_cache == 'true')
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.frontend-infrastructure.outputs.distribution_id }} \
            --paths "/*"

  # Job 5: Populate DynamoDB (opzionale)
  populate-dynamodb:
    name: Populate DynamoDB (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, backend-deploy]
    if: |
      needs.backend-deploy.result == 'success' &&
      (contains(github.event.head_commit.message, '[populate-db]') ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.populate_dynamodb == 'true'))

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      # ... (steps del job populate-dynamodb rimangono invariati)
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Install dependencies
        run: pip install boto3 jq
      - name: Check dilemma files
        working-directory: backend
        run: |
          echo "ðŸ“‹ Checking dilemma files..."
          if [ -f "dilemmas_it.json" ] && [ -f "dilemmas_en.json" ]; then
            echo "MULTILANG=true" >> $GITHUB_ENV
            en_count=$(jq '. | length' dilemmas_en.json)
            it_count=$(jq '. | length' dilemmas_it.json)
            echo "âœ… Found $en_count English + $it_count Italian dilemmas"
          elif [ -f "dilemmas_en.json" ]; then
            echo "MULTILANG=false" >> $GITHUB_ENV
            count=$(jq '. | length' dilemmas_en.json)
            echo "âœ… Found $count dilemmas"
          else
            echo "âŒ No dilemma files found!"
            exit 1
          fi

          echo "ðŸ“– Checking story flow files..."
          if [ -f "story_flows_it.json" ] && [ -f "story_flows_en.json" ]; then
            en_flows=$(jq '. | length' story_flows_en.json)
            it_flows=$(jq '. | length' story_flows_it.json)
            echo "âœ… Found $en_flows English + $it_flows Italian story flows"
          else
            echo "âš ï¸ No story flow files found (optional)"
          fi
      - name: Backup DynamoDB
        run: |
          timestamp=$(date +%Y%m%d-%H%M%S)
          TABLE_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-dilemmas"
          aws dynamodb create-backup --table-name $TABLE_NAME --backup-name "backup-$timestamp" --region ${{ env.AWS_REGION }}
          echo "ðŸ’¾ Backup created: backup-$timestamp"
      - name: Populate DynamoDB Dilemmas
        working-directory: backend
        run: |
          echo "ðŸ“Š Populating DynamoDB dilemmas..."
          TABLE_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-dilemmas"
          echo "yes" | python3 -u populate_dynamodb_multilang.py $TABLE_NAME
          echo "âœ… DynamoDB dilemmas populated!"
      - name: Populate DynamoDB Story Flows
        working-directory: backend
        run: |
          echo "ðŸ“– Populating DynamoDB story flows..."
          TABLE_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-story-flows"
          echo "yes" | python3 -u populate_story_flows.py $TABLE_NAME
          echo "âœ… DynamoDB story flows populated!"
      - name: Verify population
        run: |
          echo "ðŸ” Verifying dilemmas table..."
          DILEMMAS_TABLE="${{ needs.setup.outputs.environment }}-moral-torture-machine-dilemmas"
          dilemmas_total=$(aws dynamodb describe-table --table-name $DILEMMAS_TABLE --region ${{ env.AWS_REGION }} --query 'Table.ItemCount' --output text)
          echo "ðŸ“Š Total dilemmas: $dilemmas_total"

          echo "ðŸ” Verifying story flows table..."
          FLOWS_TABLE="${{ needs.setup.outputs.environment }}-moral-torture-machine-story-flows"
          flows_total=$(aws dynamodb describe-table --table-name $FLOWS_TABLE --region ${{ env.AWS_REGION }} --query 'Table.ItemCount' --output text)
          echo "ðŸ“Š Total story flows: $flows_total"

          if [ "$dilemmas_total" -eq 0 ]; then
            echo "âŒ No dilemmas in table!"
            exit 1
          fi

          if [ "$flows_total" -eq 0 ]; then
            echo "âŒ No story flows in table!"
            exit 1
          fi

          echo "âœ… All tables populated successfully!"

  # Job 6: Summary e Notifiche
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [setup, backend-deploy, frontend-deploy]
    if: always() # Esegui sempre per dare un feedback

    steps:
      - name: Create summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ðŸš€ Deployment Summary for commit ${{ github.sha }}

          **Environment:** ${{ needs.setup.outputs.environment }}

          ### Backend
          $(if [ "${{ needs.backend-deploy.result }}" == "success" ]; then
            echo "âœ… **Deployed successfully**"
            echo "**API Endpoint:** \`${{ needs.backend-deploy.outputs.api_url }}\`"
            echo "**DynamoDB Table:** \`${{ needs.setup.outputs.dynamodb_table }}\`"
          else
            echo "âŒ **Failed**"
          fi)

          ### Frontend
          $(if [ "${{ needs.frontend-deploy.result }}" == "success" ]; then
            echo "âœ… **Deployed successfully**"
            echo "**Frontend URL:** \`${{ needs.frontend-infrastructure.outputs.frontend_url }}\`"
            echo "**S3 Bucket:** \`${{ needs.frontend-infrastructure.outputs.bucket_name }}\`"
          else
            echo "âŒ **Failed**"
          fi)
          EOF

      - name: Notify Failure
        if: failure()
        run: |
          echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "Uno o piÃ¹ job sono falliti. Controlla i log per i dettagli." >> $GITHUB_STEP_SUMMARY