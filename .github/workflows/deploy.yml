# Deploy backend and frontend to dev or prod environment based on branch
name: Deploy Full Stack

# Trigger: Deploy to dev on develop branch, prod on main branch
on:
  push:
    branches:
      - main      # Production
      - develop   # Development
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      populate_dynamodb:
        description: 'Populate DynamoDB with fresh data'
        required: false
        default: false
        type: boolean
      invalidate_cache:
        description: 'Invalidate CloudFront cache'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: eu-west-1
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '22'
  TERRAFORM_VERSION: 1.9.0
  TF_VERSION_FRONTEND: '1.9.5'

jobs:
  # Job 0: Determine environment based on branch or input
  setup:
    name: Setup Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      dynamodb_table: ${{ steps.set-env.outputs.dynamodb_table }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="prod"
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            ENV="dev"
          else
            ENV="dev"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Deploying to: $ENV"

  # Job 1: Lint e Test Backend
  backend-lint-test:
    name: Backend Lint & Test
    runs-on: ubuntu-latest
    needs: setup
    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
          enable-cache: false # Disabilitato cache perchÃ© non esiste uv.lock

      - name: Install dependencies
        run: uv pip install --system -r requirements.txt

      - name: Lint with ruff
        continue-on-error: true
        run: |
          uv pip install --system ruff
          ruff check . || true

      - name: Check Python syntax
        run: |
          python -m py_compile src/backend_fastapi.py
          python -m py_compile scripts/populate_dynamodb_multilang.py
          python -m py_compile scripts/populate_story_flows.py

  # Job 2: Deploy Backend
  backend-deploy:
    name: Deploy Backend (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, backend-lint-test]
    defaults:
      run:
        working-directory: ./backend

    permissions:
      contents: read
      id-token: write

    outputs:
      api_url: ${{ steps.api-endpoint.outputs.api_url }}

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Build Lambda package
        run: |
          rm -rf lambda_deployment lambda_function.zip
          mkdir -p lambda_deployment
          cp src/backend_fastapi.py lambda_deployment/

          cd lambda_deployment
          pip install \
            --target . \
            --platform manylinux2014_x86_64 \
            --implementation cp \
            --python-version ${{ env.PYTHON_VERSION }} \
            --only-binary=:all: \
            -r ../requirements.txt

          zip -q -r ../lambda_function.zip .
          cd ..

          echo "ðŸ“¦ Lambda package size: $(du -h lambda_function.zip)"

      - name: Create/Update Secrets Manager Secret
        run: |
          SECRET_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-groq-api-key"

          # Check if secret exists
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "Secret exists, updating..."
            aws secretsmanager put-secret-value \
              --secret-id "$SECRET_NAME" \
              --secret-string "${{ secrets.GROQ_API_KEY }}" \
              --region ${{ env.AWS_REGION }}
          else
            echo "Secret does not exist, will be created by Terraform"
          fi

      - name: Terraform Init & Apply
        working-directory: ./backend/terraform
        env:
          TF_VAR_groq_api_key: ${{ secrets.GROQ_API_KEY }}
          TF_VAR_environment: ${{ needs.setup.outputs.environment }}
          TF_VAR_stack_name: moral-torture-machine
        run: |
          terraform init

          # Select or create workspace
          terraform workspace select ${{ needs.setup.outputs.environment }} || terraform workspace new ${{ needs.setup.outputs.environment }}

          # Apply with environment variables
          terraform apply -auto-approve

      - name: Get API Endpoint
        id: api-endpoint
        working-directory: ./backend/terraform
        run: |
          API_URL=$(terraform output -raw api_endpoint)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "âœ… API Endpoint: $API_URL"

      - name: Test API Health
        run: |
          API_URL="${{ steps.api-endpoint.outputs.api_url }}"
          echo "ðŸ§ª Testing API at: $API_URL"
          sleep 10 # Aggiunto un breve delay per dare tempo all'API Gateway di propagarsi

          # Test root endpoint
          echo "Testing root endpoint..."
          curl -f -s --retry 3 --retry-delay 5 "$API_URL/" || exit 1

          # Test get-dilemma endpoint (may fail if DB is empty, but API should still return 500)
          echo "Testing get-dilemma endpoint..."
          RESPONSE=$(curl -s --retry 3 --retry-delay 5 "$API_URL/get-dilemma" -w "%{http_code}" -o /tmp/response.txt)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)

          # Accept 200 (success), 404 (no dilemmas), or 500 (empty DB) as valid responses
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "404" ] && [ "$HTTP_CODE" != "500" ]; then
            echo "âŒ Unexpected HTTP code: $HTTP_CODE"
            cat /tmp/response.txt
            exit 1
          fi

          echo "âœ… API health check passed! HTTP Code: $HTTP_CODE"

      - name: Cleanup Lambda package
        run: |
          rm -rf lambda_function.zip lambda_deployment
          echo "ðŸ§¹ Cleaned up temporary Lambda files"

  # Job 3: Deploy Frontend Infrastructure
  frontend-infrastructure:
    name: Frontend Infrastructure (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: setup
    defaults:
      run:
        working-directory: frontend/terraform

    permissions:
      contents: read
      id-token: write

    outputs:
      bucket_name: ${{ steps.outputs.outputs.bucket_name }}
      distribution_id: ${{ steps.outputs.outputs.distribution_id }}
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION_FRONTEND }}

      - name: Terraform Init & Apply
        env:
          TF_VAR_environment: ${{ needs.setup.outputs.environment }}
          TF_VAR_stack_name: moral-torture-machine
          TF_VAR_domain_name: ${{ needs.setup.outputs.environment == 'prod' && 'moraltorturemachine.com' || '' }}
          TF_VAR_use_custom_domain: ${{ needs.setup.outputs.environment == 'prod' && 'true' || 'false' }}
        run: |
          terraform init

          # Select or create workspace
          terraform workspace select ${{ needs.setup.outputs.environment }} || terraform workspace new ${{ needs.setup.outputs.environment }}

          # Apply with environment variables
          terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: outputs
        run: |
          echo "bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
          echo "distribution_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "frontend_url=$(terraform output -raw frontend_url)" >> $GITHUB_OUTPUT

  # Job 4: Build e Deploy Frontend
  frontend-deploy:
    name: Build & Deploy Frontend (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, frontend-infrastructure]

    permissions:
      contents: read
      id-token: write

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          cache-dependency-path: 'frontend/pnpm-lock.yaml'

      - name: Install dependencies
        working-directory: frontend
        run: pnpm install --no-frozen-lockfile --ignore-workspace

      - name: Build frontend
        working-directory: frontend
        run: pnpm build --mode ${{ needs.setup.outputs.environment }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        working-directory: frontend
        run: |
          aws s3 sync dist/ s3://${{ needs.frontend-infrastructure.outputs.bucket_name }}/ --delete

      - name: Invalidate CloudFront cache
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.invalidate_cache == 'true')
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.frontend-infrastructure.outputs.distribution_id }} \
            --paths "/*"

  # Job 4b: Build Android APK (solo per prod)
  android-build:
    name: Build Android APK
    runs-on: ubuntu-latest
    needs: [setup, frontend-infrastructure, backend-deploy]
    if: needs.setup.outputs.environment == 'prod'

    permissions:
      contents: write # Per upload release artifacts

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          cache-dependency-path: 'frontend/pnpm-lock.yaml'

      - name: Setup Java (for Android build)
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Install dependencies
        working-directory: frontend
        run: pnpm install --no-frozen-lockfile --ignore-workspace

      - name: Build web app
        working-directory: frontend
        env:
          VITE_API_URL: ${{ needs.backend-deploy.outputs.api_url }}
        run: pnpm build --mode prod

      - name: Sync Capacitor
        working-directory: frontend
        run: npx cap sync android

      - name: Grant execute permission for gradlew
        working-directory: frontend
        run: chmod +x android/gradlew

      - name: Build Android APK (Debug)
        working-directory: frontend/android
        run: ./gradlew assembleDebug

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-app-debug
          path: frontend/android/app/build/outputs/apk/debug/app-debug.apk
          retention-days: 30

      - name: Get APK info
        id: apk-info
        working-directory: frontend
        run: |
          APK_PATH="android/app/build/outputs/apk/debug/app-debug.apk"
          APK_SIZE=$(du -h "$APK_PATH" | cut -f1)
          echo "apk_size=$APK_SIZE" >> $GITHUB_OUTPUT
          echo "âœ… APK built successfully! Size: $APK_SIZE"

      - name: Comment on commit with APK download link
        uses: actions/github-script@v7
        with:
          script: |
            const apkSize = '${{ steps.apk-info.outputs.apk_size }}';
            const runUrl = `https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            
            github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `ðŸ“± **Android APK Built Successfully!**\n\n` +
                    `âœ… APK Size: ${apkSize}\n` +
                    `ðŸ“¦ [Download APK from Actions artifacts](${runUrl})\n\n` +
                    `_Build triggered by: ${context.actor}_`
            });

  # Job 5: Populate DynamoDB (opzionale)
  populate-dynamodb:
    name: Populate DynamoDB (${{ needs.setup.outputs.environment }})
    runs-on: ubuntu-latest
    needs: [setup, backend-deploy]
    if: |
      needs.backend-deploy.result == 'success' &&
      (contains(github.event.head_commit.message, '[populate-db]') ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.populate_dynamodb == 'true'))

    environment:
      name: ${{ needs.setup.outputs.environment }}

    steps:
      # ... (steps del job populate-dynamodb rimangono invariati)
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Install dependencies
        run: pip install boto3 jq
      - name: Check dilemma files
        working-directory: backend
        run: |
          echo "ðŸ“‹ Checking dilemma files..."
          if [ -f "data/dilemmas_it.json" ] && [ -f "data/dilemmas_en.json" ]; then
            echo "MULTILANG=true" >> $GITHUB_ENV
            en_count=$(jq '. | length' data/dilemmas_en.json)
            it_count=$(jq '. | length' data/dilemmas_it.json)
            echo "âœ… Found $en_count English + $it_count Italian dilemmas"
          elif [ -f "data/dilemmas_en.json" ]; then
            echo "MULTILANG=false" >> $GITHUB_ENV
            count=$(jq '. | length' data/dilemmas_en.json)
            echo "âœ… Found $count dilemmas"
          else
            echo "âŒ No dilemma files found!"
            exit 1
          fi

          echo "ðŸ“– Checking story flow files..."
          if [ -f "data/story_flows_it.json" ] && [ -f "data/story_flows_en.json" ]; then
            en_flows=$(jq '. | length' data/story_flows_en.json)
            it_flows=$(jq '. | length' data/story_flows_it.json)
            echo "âœ… Found $en_flows English + $it_flows Italian story flows"
          else
            echo "âš ï¸ No story flow files found (optional)"
          fi
      - name: Backup DynamoDB
        run: |
          timestamp=$(date +%Y%m%d-%H%M%S)
          TABLE_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-dilemmas"
          aws dynamodb create-backup --table-name $TABLE_NAME --backup-name "backup-$timestamp" --region ${{ env.AWS_REGION }}
          echo "ðŸ’¾ Backup created: backup-$timestamp"
      - name: Populate DynamoDB Dilemmas
        working-directory: backend
        run: |
          echo "ðŸ“Š Populating DynamoDB dilemmas..."
          TABLE_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-dilemmas"
          python3 -u scripts/populate_dynamodb_multilang.py --auto-confirm $TABLE_NAME
          echo "âœ… DynamoDB dilemmas populated!"
      - name: Populate DynamoDB Story Flows
        working-directory: backend
        run: |
          echo "ðŸ“– Populating DynamoDB story flows..."
          TABLE_NAME="${{ needs.setup.outputs.environment }}-moral-torture-machine-story-flows"

          echo "DEBUG: Table name: $TABLE_NAME"
          echo "DEBUG: Checking if JSON files exist..."
          ls -la data/story_flows_*.json

          python3 -u scripts/populate_story_flows.py --auto-confirm $TABLE_NAME
          POPULATE_EXIT_CODE=$?

          echo "DEBUG: Populate script exit code: $POPULATE_EXIT_CODE"

          if [ $POPULATE_EXIT_CODE -ne 0 ]; then
            echo "âŒ Populate script failed with exit code $POPULATE_EXIT_CODE"
            exit 1
          fi

          echo "âœ… DynamoDB story flows populated!"

          echo "DEBUG: Immediately checking table contents..."
          aws dynamodb scan --table-name $TABLE_NAME --region ${{ env.AWS_REGION }} --select COUNT --query 'Count' --output text
      - name: Verify population
        run: |
          echo "ðŸ” Verifying dilemmas table..."
          DILEMMAS_TABLE="${{ needs.setup.outputs.environment }}-moral-torture-machine-dilemmas"
          dilemmas_total=$(aws dynamodb scan --table-name $DILEMMAS_TABLE --region ${{ env.AWS_REGION }} --select COUNT --query 'Count' --output text)
          echo "ðŸ“Š Total dilemmas: $dilemmas_total"

          echo "ðŸ” Verifying story flows table..."
          FLOWS_TABLE="${{ needs.setup.outputs.environment }}-moral-torture-machine-story-flows"
          flows_total=$(aws dynamodb scan --table-name $FLOWS_TABLE --region ${{ env.AWS_REGION }} --select COUNT --query 'Count' --output text)
          echo "ðŸ“Š Total story flows: $flows_total"

          if [ "$dilemmas_total" -eq 0 ]; then
            echo "âŒ No dilemmas in table!"
            exit 1
          fi

          if [ "$flows_total" -eq 0 ]; then
            echo "âŒ No story flows in table!"
            exit 1
          fi

          echo "âœ… All tables populated successfully!"

  # Job 6: Summary e Notifiche
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [setup, backend-deploy, frontend-deploy, android-build]
    if: always() # Esegui sempre per dare un feedback

    steps:
      - name: Create summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## ðŸš€ Deployment Summary for commit ${{ github.sha }}

          **Environment:** ${{ needs.setup.outputs.environment }}

          ### Backend
          $(if [ "${{ needs.backend-deploy.result }}" == "success" ]; then
            echo "âœ… **Deployed successfully**"
            echo "**API Endpoint:** \`${{ needs.backend-deploy.outputs.api_url }}\`"
            echo "**DynamoDB Table:** \`${{ needs.setup.outputs.dynamodb_table }}\`"
          else
            echo "âŒ **Failed**"
          fi)

          ### Frontend
          $(if [ "${{ needs.frontend-deploy.result }}" == "success" ]; then
            echo "âœ… **Deployed successfully**"
            echo "**Frontend URL:** \`${{ needs.frontend-infrastructure.outputs.frontend_url }}\`"
            echo "**S3 Bucket:** \`${{ needs.frontend-infrastructure.outputs.bucket_name }}\`"
          else
            echo "âŒ **Failed**"
          fi)

          ### Android APK
          $(if [ "${{ needs.android-build.result }}" == "success" ]; then
            echo "âœ… **Built successfully**"
            echo "ðŸ“¦ **Download from:** [Actions Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          elif [ "${{ needs.android-build.result }}" == "skipped" ]; then
            echo "â­ï¸ **Skipped** (only builds on production)"
          else
            echo "âŒ **Failed**"
          fi)
          EOF

      - name: Notify Failure
        if: failure()
        run: |
          echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "Uno o piÃ¹ job sono falliti. Controlla i log per i dettagli." >> $GITHUB_STEP_SUMMARY