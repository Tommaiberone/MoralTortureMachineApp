# Esegue l'intero processo di deploy per backend e frontend
# a ogni push sul branch 'main'.
name: Deploy Full Stack on Main Push

# Trigger: Esegui SOLO quando viene fatto un push sul branch 'main'.
on:
  push:
    branches:
      - main
  # Aggiunto workflow_dispatch per poterlo avviare manualmente se necessario,
  # mantenendo la logica originale per i parametri opzionali.
  workflow_dispatch:
    inputs:
      populate_dynamodb:
        description: 'Populate DynamoDB with fresh data'
        required: false
        default: false
        type: boolean
      invalidate_cache:
        description: 'Invalidate CloudFront cache'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: eu-west-1
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'
  TERRAFORM_VERSION: 1.9.0
  TF_VERSION_FRONTEND: '1.9.5'
  DYNAMODB_TABLE_NAME: moral-torture-machine-dilemmas

jobs:
  # Job 1: Lint e Test Backend
  backend-lint-test:
    name: Backend Lint & Test
    runs-on: ubuntu-latest
    # RIMOSSO: Condizione 'if'. Questo job si eseguir√† sempre.
    defaults:
      run:
        working-directory: ./backend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
          enable-cache: false # Disabilitato cache perch√© non esiste uv.lock

      - name: Install dependencies
        run: uv pip install --system -r requirements.txt

      - name: Lint with ruff
        continue-on-error: true
        run: |
          uv pip install --system ruff
          ruff check . || true

      - name: Check Python syntax
        run: |
          python -m py_compile backend_fastapi.py
          python -m py_compile populate_dynamodb_multilang.py

  # Job 2: Deploy Backend
  backend-deploy:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: backend-lint-test
    # RIMOSSO: Condizione 'if'. Questo job si eseguir√† sempre dopo il lint/test.
    defaults:
      run:
        working-directory: ./backend

    permissions:
      contents: read
      id-token: write

    outputs:
      api_url: ${{ steps.api-endpoint.outputs.api_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Build Lambda package
        run: |
          rm -rf lambda_deployment lambda_function.zip
          mkdir -p lambda_deployment
          cp backend_fastapi.py lambda_deployment/

          cd lambda_deployment
          pip install \
            --target . \
            --platform manylinux2014_x86_64 \
            --implementation cp \
            --python-version ${{ env.PYTHON_VERSION }} \
            --only-binary=:all: \
            -r ../requirements.txt

          zip -q -r ../lambda_function.zip .
          cd ..

          echo "üì¶ Lambda package size: $(du -h lambda_function.zip)"

      - name: Terraform Init & Apply
        working-directory: ./backend/terraform
        run: |
          terraform init
          terraform apply -auto-approve \
            -var="groq_api_key=${{ secrets.GROQ_API_KEY }}"

      - name: Get API Endpoint
        id: api-endpoint
        working-directory: ./backend/terraform
        run: |
          API_URL=$(terraform output -raw api_endpoint)
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ API Endpoint: $API_URL"

      - name: Test API Health
        run: |
          API_URL="${{ steps.api-endpoint.outputs.api_url }}"
          echo "üß™ Testing API at: $API_URL"
          sleep 10 # Aggiunto un breve delay per dare tempo all'API Gateway di propagarsi

          # Test root endpoint
          echo "Testing root endpoint..."
          curl -f -s --retry 3 --retry-delay 5 "$API_URL/" || exit 1

          # Test get-dilemma endpoint (may fail if DB is empty, but API should still return 500)
          echo "Testing get-dilemma endpoint..."
          RESPONSE=$(curl -s --retry 3 --retry-delay 5 "$API_URL/get-dilemma" -w "%{http_code}" -o /tmp/response.txt)
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)

          # Accept 200 (success), 404 (no dilemmas), or 500 (empty DB) as valid responses
          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "404" ] && [ "$HTTP_CODE" != "500" ]; then
            echo "‚ùå Unexpected HTTP code: $HTTP_CODE"
            cat /tmp/response.txt
            exit 1
          fi

          echo "‚úÖ API health check passed! HTTP Code: $HTTP_CODE"

  # Job 3: Deploy Frontend Infrastructure
  frontend-infrastructure:
    name: Frontend Infrastructure
    runs-on: ubuntu-latest
    # RIMOSSO: Condizione 'if'. Questo job si eseguir√† sempre.
    defaults:
      run:
        working-directory: web/terraform

    permissions:
      contents: read
      id-token: write

    outputs:
      bucket_name: ${{ steps.outputs.outputs.bucket_name }}
      distribution_id: ${{ steps.outputs.outputs.distribution_id }}
      frontend_url: ${{ steps.outputs.outputs.frontend_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION_FRONTEND }}

      - name: Terraform Init & Apply
        run: |
          terraform init
          terraform apply -auto-approve

      - name: Get Terraform Outputs
        id: outputs
        run: |
          echo "bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
          echo "distribution_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "frontend_url=$(terraform output -raw frontend_url)" >> $GITHUB_OUTPUT

  # Job 4: Build e Deploy Frontend
  frontend-deploy:
    name: Build & Deploy Frontend
    runs-on: ubuntu-latest
    needs: frontend-infrastructure
    # RIMOSSO: Condizione 'if'. Si eseguir√† sempre dopo il deploy dell'infrastruttura.
    defaults:
      run:
        working-directory: web

    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'
          cache-dependency-path: web/pnpm-lock.yaml

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Build frontend
        run: pnpm build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload to S3
        run: |
          aws s3 sync dist/ s3://${{ needs.frontend-infrastructure.outputs.bucket_name }}/ --delete

      - name: Invalidate CloudFront cache
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.invalidate_cache == 'true')
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.frontend-infrastructure.outputs.distribution_id }} \
            --paths "/*"

  # Job 5: Populate DynamoDB (opzionale)
  populate-dynamodb:
    name: Populate DynamoDB
    runs-on: ubuntu-latest
    needs: backend-deploy
    # MANTENUTO: Questa condizione √® utile per non popolare il DB a ogni commit,
    # che potrebbe essere un'operazione lenta o indesiderata.
    # Si attiva solo con un messaggio di commit specifico o con trigger manuale.
    if: |
      needs.backend-deploy.result == 'success' &&
      (contains(github.event.head_commit.message, '[populate-db]') ||
       (github.event_name == 'workflow_dispatch' && github.event.inputs.populate_dynamodb == 'true'))

    steps:
      # ... (steps del job populate-dynamodb rimangono invariati)
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Install dependencies
        run: pip install boto3 jq
      - name: Check dilemma files
        working-directory: backend
        run: |
          echo "üìã Checking dilemma files..."
          if [ -f "dilemmas_it.json" ] && [ -f "dilemmas.json" ]; then
            echo "MULTILANG=true" >> $GITHUB_ENV
            en_count=$(jq '. | length' dilemmas.json)
            it_count=$(jq '. | length' dilemmas_it.json)
            echo "‚úÖ Found $en_count English + $it_count Italian dilemmas"
          elif [ -f "dilemmas.json" ]; then
            echo "MULTILANG=false" >> $GITHUB_ENV
            count=$(jq '. | length' dilemmas.json)
            echo "‚úÖ Found $count dilemmas"
          else
            echo "‚ùå No dilemma files found!"
            exit 1
          fi
      - name: Backup DynamoDB
        run: |
          timestamp=$(date +%Y%m%d-%H%M%S)
          aws dynamodb create-backup --table-name ${{ env.DYNAMODB_TABLE_NAME }} --backup-name "backup-$timestamp" --region ${{ env.AWS_REGION }}
          echo "üíæ Backup created: backup-$timestamp"
      - name: Populate DynamoDB
        working-directory: backend
        run: |
          echo "üìä Populating DynamoDB..."
            python3 -u populate_dynamodb_multilang.py ${{ env.DYNAMODB_TABLE_NAME }} <<EOF
          echo "‚úÖ DynamoDB populated!"
      - name: Verify population
        run: |
          total=$(aws dynamodb describe-table --table-name ${{ env.DYNAMODB_TABLE_NAME }} --region ${{ env.AWS_REGION }} --query 'Table.ItemCount' --output text)
          echo "üìä Total items: $total"
          if [ "$total" -eq 0 ]; then
            echo "‚ùå No items in table!"
            exit 1
          fi

  # Job 6: Summary e Notifiche
  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [backend-deploy, frontend-deploy]
    if: always() # Esegui sempre per dare un feedback

    steps:
      - name: Create summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          ## üöÄ Deployment Summary for commit ${{ github.sha }}

          ### Backend
          $(if [ "${{ needs.backend-deploy.result }}" == "success" ]; then
            echo "‚úÖ **Deployed successfully**"
            echo "**API Endpoint:** \`${{ needs.backend-deploy.outputs.api_url }}\`"
          else
            echo "‚ùå **Failed**"
          fi)

          ### Frontend
          $(if [ "${{ needs.frontend-deploy.result }}" == "success" ]; then
            echo "‚úÖ **Deployed successfully**"
            echo "**Frontend URL:** \`${{ needs.frontend-infrastructure.outputs.frontend_url }}\`"
          else
            echo "‚ùå **Failed**"
          fi)
          EOF

      - name: Notify Failure
        if: failure()
        run: |
          echo "## ‚ùå Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "Uno o pi√π job sono falliti. Controlla i log per i dettagli." >> $GITHUB_STEP_SUMMARY